# JavaScript - Полный Курс JavaScript Для Начинающих

[YOUTUBE](https://www.youtube.com/watch?v=CxgOKJh4zWE&t=12273s)

<hr>

- **Выражение** -- всегда возвращает значение
  - Не только возвращает значение, но и выполняет другие действия (side effect)
- **Функции** -- блок кода который можно выполнять многократно
  - **Функция может быть**
    - Именованной
    - Анонимной
    - Присвоена переменной
    - Аргументов при вызове другой функции
    - Значение свойства (метода) объекта
  - Функция возвращает UNDEFINED если нет инструкции RETURN
  - Внутри функции не рекомендуется мутировать внешние объекты
  - Правила работы с функциями
    - Называть функции исходя из выполняемых задачи
    - Одна функции должна выполнять одну задачу
    - Не рекомендуется изменять внешние относительно функции переменные
      - Необходимо всегда создавать копии внешних переменных
- **Объекты** --
  - метод -- свойство объекта, значение которого функция

<hr>

Объект это набор свойств -- ключ: значение

<hr>

- Примитивные типы
  - string
  - number
  - boolean
  - null
  - undefined
  - symbol
- Ссылочный тип (Это объект)
  - object

<hr>

# Мутация в JS
- copy by value
- cope by reference

# Область видимости
- Определяет границы действия переменной
- Типы областей видимости
  - Глобальная область видимости
  - Область видимости функции
  - Область видимости блока
- Правила работы с переменными
  - Все переменные объявлять перед их использованием
  - Стараться использовать CONST везде, где это возможно
  - Внутри функций не изменять переменные с внешних областей видимости

<hr>

# Операторы
 - Встроенная в JS функция
   - Операторы
     - Арифметические -- **+, -, *, /**
     - Сравнения -- **===, !==, >=, <=**
     - Логические **&&, ||, !**
     - Присваивание **=**
       - a = 10 -- имеет два операнда
       
                 ```JS
                    function = (переменная, выражение) {
                        1. Получение результаты выражения
                        2. Поиск переменной по имени
                        3. Присваивание результата значения переменной
                        4. Возврат результата значения
                    }
                 ``` 
     - Текстовые операторы
       - typeof
       - instanceof
       - new
       - delete
 - Операнды (аргументы)
   - то что находится слева и справа от оператора **пример: a = true**
 - Унарные и бинарные
   - **Формы записи**
     - инфиксная
       - Когда оператор находится между операндами 
         - a = true
         - a + b
         - a += 5
         - a || b
         - a > b
   - префиксная
     - Когда оператор стоит перед операндом
       - ++a
         - Может быть и постфиксная запись 
           - a++
           - function () {}
       - delete obj.a
       - typeof a
   - постфиксная запись
   - **УНАРНЫЕ**
     - у унарных операторов всегда один операнд (аргумент)
       - a++
       - +a
       - delete obj.a
       - typeof a
       - new Object()
   - **БИНАРНЫЕ**
     - у бинарных операторов два операнда (аргумента)
       - a = 5
       - a + b
       - a += 5
       - a === b
       - a && b

<hr>

# Приоритетность операторов

[Таблица приоритета операторов](https://www.bestprog.net/ru/2022/05/22/javascript-operators-priority-ru/)

Приоритет операторов определяет очередность выполнения операторов в выражении. Существует ряд операторов, обладающих 
одинаковым приоритетом. В этом случае очередность выполнения операторов определяется направлением вычислений, 
которое называется ассоциативностью. Направление вычислений для операторов с равным приоритетом может быть:

- **Левоассоциативные:** операторы с одинаковым приоритетом выполняются слева направо. Например, в выражении a - b - c, 
  операторы - с равным приоритетом выполняются слева направо, то есть сначала выполняется a - b, а затем результат 
  вычитания используется для вычисления результат - c.

- **Правоассоциативные:** операторы с одинаковым приоритетом выполняются справа налево. Например, в выражении a = b = c, 
  операторы = с равным приоритетом выполняются справа налево, то есть сначала выполняется b = c, а затем результат 
  присваивания используется для присваивания a = результат.

<hr>

# Логические операторы

- Не **!**
  - **Чаще всего используется в условных инструкциях**
    - **!10 // false**
    - **!0 // true**
    - **!'abc' // false**
    - **!'' // true**
    - **!true // false**
    - **!undefined // true**
  - Всегда возвращает boolean
- И **&&** (Ищет первое ложное значение)
  - Оператор короткого замыкания
  - Возвращает значение одного из операндов
    - Выражение 1 && Выражение 2
      - Если "Выражение 1" ложно:
        - Выражение 2 игнорируется
        - Возвращается результат "Выражения 1"
- Или **||** (Ищет первое истинное значение)
  - Оператор короткого замыкания
  - Возвращает значение одного из операндов
    - Выражение 1 || Выражение 2
      - Если "Выражение 1" истина:
        - Выражение 2 игнорируется
        - Возвращается результат "Выражения 1"

- **Ложные значения**
  - false
  - 0
  - ""
  - undefined
  - null

- **Истинные значения**
  - " " (Строка с пробелом)

- **Цепочка операторов**
  - a && b && c && d
  - a || b || c || d

<hr/>

# Оператор разделения объекта на свойства
- Создает новый объект и если его перезаписывать то верхние объекты на изменятся
  - Мутирования объекта не будет, если у исходных объектов не было вложенных объектов

<hr/>

# Конкатенация строк
- Оператор **+** для конкатенации строк
  - **10 + 'years' интерпретатор преобразует в строку**
    - Называется автоматическая конвертация типов
  - 'Hello' + ' ' + 'world' --> 'Hello world'
- Шаблонные строки
  - `${variable1} ${variable2}`

<hr/>

# Функциональные выражения

<table>
  <tr>
    <th>Объявленная функция</th>
    <th>Функциональное выражение</th>
  </tr>
  <tr>
    <td>
        <code>
          function myFn(a, b) {
            let c
            a = a + 1
            c = a + b
            return c
          }
        </code>
      <br>
      <h4>
        При объявлении такой функции создается переменная с именем "myFn", а значение
        этой переменной будет функция
      </h4>
    </td>
    <td>
        <code>
          function (a, b) {
            let c
            a = a + 1
            c = a + b
            return c
          }
        </code>
      <br>
      <h4>У ФВ нет имени функции!</h4>
      <h4>Функциональные выражения всегда анонимные</h4>
    </td>
  </tr>
</table>

<table>
  <tr>
    <th></th> 
    <th>Объявленная функция</th> 
    <th>Функциональное выражение</th> 
  </tr>
  <tr>
    <td>Имеет имя</td>
    <td>Да</td>
    <td>Нет</td>
  </tr>
  <tr>
    <td>Можно использовать <br/> автономно</td>
    <td>Да</td>
    <td>Нет</td>
  </tr>
  <tr>
    <td>Можно присваивать <br/> переменной</td>
    <td>Да</td>
    <td>Да</td>
  </tr>
  <tr>
    <td>Можно использовать <br/> как аргумент в вызове <br> другой функции</td>
    <td>Да</td>
    <td>Да</td>
  </tr>
</table>

- Присваивание функционального выражения переменной
  ```js
    const myFunction = function (a, b) {
      let c
      a = a + 1
      c = a + b
      return c
    }
  ```

<hr/>

# Стрелочные функции
```js
    (a, b) => { // Нет имени
      let c
      a = a + 1
      c = a + b
      return c
    }
  ```
- Стрелочные функции это выражения
- Стрелочные функции всегда анонимные

- Переменная в которую записана анонимная стрелочная функции больше нельзя перезаписать
```js
  // МОЖНО ПЕРЕЗАПИСАТЬ myFunction
  let myFunction = function (a, b) {
    let c
    a = a + 1
    c = a + b
    return c
  }
  
  myFunction = ''

// НЕЛЬЗЯ ПЕРЕЗАПИСАТЬ myFunction2
  let myFunction2 = (a, b) => {
    let c
    a = a + 1
    c = a + b
    return c
  }

  myFunction2 = ''
```

- Сокращения в стрелочных функциях

```js
  a => {
    console.log('Test', a)
  } 
```

```js
  (a, b) => a + b
```

# Обработка ошибок в JS

- Uncaught Error: Не пойманная ошибка
- throw new Error('Some error') -- Генерирует сообщение об ошибке
  - Если JS выведет ошибку, то код остановит своё выполнение
  - Если использовать TRY/CATCH, то выполнение кода продолжится

# Инструкции
- Выражение всегда возвращает значение (Присваивание значения переменной)
  - Всегда возвращает значение
- Инструкция -- объявление переменной с помощью ключевого слова **let**
  - Выполняет определенное действие
  - Точка с запятой не требуется после блока инструкций
  - Инструкция не может стать выражением
- Выражение - Инструкция
  - Если выражение написано на отдельной строке, то это **Выражение инструкция**
- Инструкция - Выражение **НО** инструкция не может стать выражением

# Как отличить выражение от инструкции

- Выражения могут быть использованы как аргументы в вызовах функций
- Инструкции не могут быть использованы как аргументы в вызовах функций

- Точка с запятой ставится после всех инструкций, но их можно опускать
- Нужно следить что бы разные инструкции находились на разных строках кода

- Есть
  - Выражения
  - Инструкции
  - Выражения инструкции

```JS
function myFn(a) {
  console.log(a);
}

const b = true;
let c = 10;

myFn(2 + 3) // 5
myFn(b) // true
myFn(c = c + 1) // 11

// myFn(c = c + 1;) Uncaught SyntaxError
// myFn(let d) Uncaught SyntaxError
```

# Массивы

- Массив это объект с цифровыми именами свойств
- Формат записи массивов

```JS
const myArray = [1, 2, 3]
console.log(myArray) // [1, 2, 3]

const myArray2 = new Array(1, 2, 3) // Создание нового экземпляра класса
console.log(myArray2) // [1, 2, 3]
```

### Оператор сравнения для массивов

- Что бы сравнить массив необходимо сравнить ссылки по которой он находится 

```JS
const array = [1, 2, 3]
const array2 = [1, 2, 3]
const array3 = array

console.log(array === array2) // false
console.log(array === array3) // true
```

### Массив VS Объект
- **Порядок элементов в массиве важен**
  - Так как каждый элемент массива **имеет свой индекс**
- Массив и объект отличаются прототипом
  - {} -- __proto__: Object
  - [] -- __proto__: Array
- **ПРОТОТИПЫ** влияют на то какие методы будут доступны {} и []

### Чтение значений массива

```JS
const myArray = [1, true, 'Egor']
console.log(myArray) // [1, true, 'Egor']

console.log(myArray[0]) // 1
console.log(myArray[1]) // true

console.log(myArray.length) // 3
```

### Длина массива
- Свойство length обновляется автоматически при добавлении нового элемента в массив
```JS
const myArray = [1,2,3,4]
console.log(myArray) // [1,2,3,4]
console.log(myArray.length) // 4

myArray[2] = 'abc'

console.log(myArray) // [1,2,'abc',4]
console.log(myArray[2]) // 'abc'

myArray[4] = true

console.log(myArray) // [1,2,'abc',4,true]
console.log(myArray.length) // 5
```

### Методы массива
- Функции высшего порядка в массивах или методы/функции прототипов
- Каждый массив который создается, является экземпляром массива
  - **При создании переменой с массивом она наследует все методы массивов**
<hr>

- PUSH -- Добавление элемента в конец массива
- POP -- Удаление элемента с конца массива и возвращает его
- unshift -- Добавление элемента в начало массива
- shift -- Удаляет первый элемент в массиве и возвращает его
- forEach -- Выполняет указанную функцию один раз для каждого элемента в массиве
  - **Метод forEach не меняет оригинальный массив**
  - Метод с помощью которого можно перебрать все элементы массива и выполнить с ними действие
  - **ПРИМЕР** kats/_key_objects.js
- map -- Вызывает переданную callback функцию один раз для каждого элемента, в порядке их появления и конструирует новый массив из результатов её вызова.
  - **Метод forEach не меняет оригинальный массив**
  - Всегда вернет массив такой же длины, что и оригинальный массив

## forEach для объектов
- Object.keys(myObject) -- Вернет массив ключей объекта
- Object.values(myObject) -- Вернет массив значений объекта

# Условные инструкции
- IF
  - Блок кода, выполняемый однократно, если Условие правдиво
- IF/ELSE
  - **IF** Блок кода, выполняемый однократно, если Условие правдиво
  - **ELSE** Блок кода, выполняемый однократно, если Условие ложно
  - SWITCH
    - **Подходит если нужно выполнять разные действия исходя из значений той или иной переменой** 
    - Альтернатива использованию конструкции if/else/if
      ```JS
      const expression = "Egor"

      switch (expression) {
        case "Egor":
          console.log(expression)
          break
        case "Roma":
          console.log(expression)
          break
        default:
          console.log("Is not name")
      }
      ```
- Тернарный оператор
  - Оператор возвращает значение
  - У тернарного оператора три операнда
  - Конструкция с тернарным оператором это выражение
  - Выражение возвращает значение

# ЦИКЛЫ
- Способ многократного выполнения одних и тех же действий
- Все циклы это инструкции
- Типы циклов
  - **for**
    ```js
        // lat i = 0; -- Начальная инструкция
        // i <= 10; -- Условие
        // i++ -- Итерационное действие
        for (let i = 0; i <= 10; i++) {
          // Блок кода, выполняемый на каждой итерации
        }
    ```
  - **while**
    - Позволяет выполнять БК пока условие правдиво
    ```js
      let i = 0 // Условие
      while (i < 5) {
        // Блок кода, выполняемый на каждой итерации
        i++
      }
    ```
  - **do ... while**
    - Используется когда нужно выполнить БК хотя бы один раз
    ```js
      let j = 0 // Условие
      do {
        // Блок кода, выполняемый на каждой итерации
        j++
      } while (j < 5)
    ```
  - for ... in ...
    ```js
      // key - название свойства объекта
      // Object - Объект
      for (key in Object) {
        // Действие с каждым свойством объекта
        // Значение свойства - Object[key]
      }
    ```
    ```JS
      // for ... in ... | для массива | НЕ РЕКОММЕНДУЕТСЯ
      // лучше использовать forEach 
      const myArray = [true, 10, "abc", null]
      for (const key in myArray) {
        console.log(myArray[key])
      }
    ```
  - for ... of ...
    - FOR ... OF ... не для объектов
    - ОБЪЕКТ не итерируемый элемент в JS
    - Для итерации по объекту его нужно конвертировать в массив Object.keys/.values
    ```JS
      const iterable = [10, 20, 30]
      const iterable2 = "Example"
      for (const value of iterable) {
        console.log(value) // 10, 20, 30 | // E, x, a, m, p, l, e
      }
    ```

# Модули
- Позволяют структурировать код
- Позволяют избегать дублирования блоков кода
- Каждый модуль это отдельная зона видимости переменных

### Правила работы с модулями
1. Модули должны быть одноцелевыми
   - Цель создание модулей, разделение большого блока кода на много маленьких, для многократного использования
2. Располагайте все **export** инструкции внизу файла
3. Располагайте все **import** инструкции вверху страницы
4. По возможности используйте **export default**

- IMPORT
- EXPORT
  - Экспортируя через default при импорте можно будет задать новое имя

# Классы и прототипы
- Синтаксис классов в ES6
- Это синтаксическая надстройка над функциями и объектами.
- Класс -- это шаблон для создания экземпляров класса

- Классы позволяют создавать прототипы для объектов
- На основании прототипов создаются экземпляры
  - Каждый экземпляр имеет свои свойства и методы.
  - Экземпляры наследуют свойства и методы прототипов

- THIS в классе указывает на экземпляр класса
- CONSTRUCTOR вызывается только при создании **нового экземпляра** класса

```JS
class Comment {
  constructor(text) {
    this.text = text
    this.votesQty = 0
  }

  // ЭТОТ МЕТОД НАХОДИТСЯ НА УРОВНЕ КЛАССА
  // ОН НЕ БУДЕТ ПРИСВОИН КАК ОТДЕЛЬНЫЙ МЕТОД КОНКРЕТНОГО ЭКЗЕМЛЯРА ЭТОГО КЛАССА
  // НО ОН БУДЕТ НАСЛЕДОВАТЬСЯ ВСЕМИ ЭКЗЕМЛЯРАМИ ЭТОГО КЛАССА
  upvote() {
    this.votesQty = 1
  }
}
```

- Создание экземпляра
```JS
// const firstComment -- Экземляр | Вернет объект который наследует все методы класса комментарий
// new Comment('First comment') -- Прототип
const firstComment = new Comment('First comment')
firstComment.upvote() // Вызываем как метод объекта firstComment
```

### Наследование по цепочке

- firstComment -> Comment -> Object
- firstComment -- является экземпляром класса Comment
- Comment -- наследует все методы Object (Object -- это глобальный класс в JS)

### Проверка принадлежности

```JS
firstComment instanceof Comment // true
firstComment instanceof Object // true
```

### Проверка принадлежности свойств экземпляру объекта
- Проверка осуществляется методом "hasOwnProperty"

```JS
firstComment.hasOwnProperty('text') // true
firstComment.hasOwnProperty('votesQty') // true
firstComment.hasOwnProperty('upvote') // false
firstComment.hasOwnProperty('hasOwnProperty') // false
```

### Статические методы
- Статический метод не будет доступен на уровне экземпляра класса
- Статический метод будет доступен как метод самого класса
```JS
class Comment {
  constructor(text) {
    this.text = text
    this.votesQty = 0
  }

  upvote() {
    this.votesQty = 1
  }
  
  // mergeComments является статическим методом объекта
  // ЭТОТ МЕТОД БУДЕТ ДОСТУПЕН, КАК СВОЙСТВО КЛАССА
  static mergeComments(first, second) {
    return `${first} ${second}`
  }
}

// Вызываем mergeComments, как метод комментария. Не создавая экземпляр класса 
Comment.mergeComments('First', 'Seconds')
```

### Расширение других классов
- При создании расширенного класса сначала вызывается конструктор родительского класса
- Получившаяся цепочка прототипов
  - myArray -> NumbersArray -> Array -> Object
```JS
// NumbersArray расширяет класс Array
class NumbersArray extends Array {
  sum() {
    console.log(this)
    return this.reduce((el, acc) => acc += el, 0)
  }
}

const myArray = new NumbersArray(2, 5, 7)

console.log(myArray)
myArray.sum()
```

# ПРОТОТИП
- Объекты в JavaScript можно организовать в цепочки так, чтобы свойство, не найденное в одном объекте, автоматически
искалось бы в другом. Связующим звеном выступает специальное свойство __proto__.
- Объект, на который указывает ссылка __proto__, называется «прототипом». В данном случае получилось, 
что animal является прототипом для rabbit.

<hr>

- Прототип это объект, который содержит такие методы как: конструктор и другие определенные вами методы
- У каждого экземпляра класса есть скрытые свойства (__proto__)
- Свойство prototype конкретного класса === свойству __proto__ любого экземпляра класса
  ```JS
    Comment.prototype === firstComment.__proto__
  ```
- Благодаря прототипам и цепочкам прототипов, которые на самом деле являются просто объектами. Мы создаем возможность 
наследования свойств и методов.
- То есть если какой, то метод не найден в каком то объекте. Мы смотрим и ищем этот объект на уровне родительского
прототипа если и там не найден то ищем дальше и так по всей цепочке прототипов

### Строки и числа ведут себя как объекты
```JS
const myName = 'Egor'
const mySecondName = new String('Eichhorn')
```

# Промисы
- Промисы позволяют отрабатывать отложенные во времени события
- Промис это обещание предоставить результат позже
- Промис может вернуть ошибку если результат предоставить невозможно

### Состояния промиса
- Когда промис только создается: __ОЖИДАНИЕ (PENDING)__ результата или ошибки
- Когда промис вернул какой-то результат: __ИСПОЛНЕН (RESOLVE)__ 
- Когда возникла ошибка: __ОТКЛОНЕН (REJECT)__

### Создание промиса
- Вновь созданный промис будет в состоянии pending
<hr>
- 
```JS
const myPromise = new Promise((resolve, reject) => {
  /*
  * Описание логики возврата результата или ошибки
  * */
})
```

### Получение результата промиса
```JS
myPromise.then((value) => {
  /*
  * Действия в случае успешного исполнения Промиса
  * Значение value - это значение, переданное в вызове функции resolve внутри Промиса
  * */
}).cache((error) => {
  /*
  * Действия в случае отклонения Промиса
  * Значение error - это значение, переданное в вызове функции reject внутри Промиса
  * */
})
```
